#!/bin/bash
# vim: softtabstop=2 shiftwidth=2 expandtab

cleanup() {
  if [[ -f "${TEMP_EFI}" && -z "${PRESERVE_TEMP_EFI}" ]]; then
    rm "${TEMP_EFI}"
  fi

  [ -f "${TEMP_KCL}" ] && rm "${TEMP_KCL}"

  [ -f "${TEMP_INPUT}" ] && rm "${TEMP_INPUT}"
}

clean_kcl() {
  # Strip leading and trailing spaces
  sed -i 's/^[[:space:]]*//g;s/[[:space:]]*$//g' "${1}"

  # Remove existing null terminators
  sed -i 's/\x0//g' "${1}"

  # Collapse multiple lines into one
  sed -i -z 's/\n/ /g' "${1}"
}

error() {
  echo "ERROR: $*" >&2
  exit 1
}


usage() {
  cat <<-EOF
	USAGE: $0 [-e <arg>] [-f <arg>] [-k <arg>] [-o <arg>]

	OPTIONS
	  -e <arg>  ZFSBootMenu EFI file
	  -f <arg>  Replace kernel command line with contents of file
	  -k <arg>  Replace kernel command line with quoted arguments
	  -o <arg>  Output file; if undefined the input file will be replaced
	  -p        Print the command line stored in the input file and exit
	  -h        Display this message and exit

	If an input file is not provided with -e, the input executable will be
	read from stdin. When reading input from stdin:

	  - If -o is not provided, the result will be written to stdout.
	  - One of -f, -k or -p is REQUIRED.

	If neither -f, -k, or -p are provided, the command line from the
	input EFI will be opened in \$EDITOR.
	EOF
}

INPUT_EFI=
OUTPUT_EFI=
ARG_FILE=
ARG_VAR=
PRINT_ONLY=

while getopts "e:f:k:o:ph" opt; do
  case "${opt}" in
    e)
      INPUT_EFI="${OPTARG}"
      ;;
    o)
      # Override the output file
      OUTPUT_EFI="${OPTARG}"
      ;;
    f)
      ARG_FILE="${OPTARG}"
      ARG_VAR=
      if [ ! -f "${ARG_FILE}" ]; then
        error "Unable to open ${ARG_FILE}"
      fi
      ;;
    k)
      ARG_VAR="${OPTARG}"
      ARG_FILE=
      ;;
    p)
      PRINT_ONLY=yes
      ;;
    h)
      usage
      exit 0
      ;;
    *)
      usage
      exit 1
      ;;
  esac
done

if ! command -v objcopy > /dev/null 2>&1 ; then
  error "Missing required binary 'objcopy'"
fi

if [ -n "${INPUT_EFI}" ] && [ ! -r "${INPUT_EFI}" ]; then
  error "Unable to open ${INPUT_EFI}"
fi

# Set OUTPUT_EFI to the input by default
if [ -z "${OUTPUT_EFI}" ]; then
  OUTPUT_EFI="${INPUT_EFI}"
fi

TEMP_INPUT=
TEMP_EFI=
TEMP_KCL=
trap cleanup EXIT INT TERM

# Process EFI kcl on stdin if no input file was specified
if [ -z "${INPUT_EFI}" ]; then
  if [ -z "${ARG_FILE}" ] && [ -z "${ARG_VAR}" ] && [ -z "${PRINT_ONLY}" ]; then
    error "reading from stdin requires one of -f, -k or -p"
  fi

  TEMP_INPUT="$(mktemp)"
  cat > "${TEMP_INPUT}"
  INPUT_EFI="${TEMP_INPUT}"
fi

TEMP_EFI="$(mktemp)"
if ! objout="$( objcopy --remove-section .cmdline "${INPUT_EFI}" "${TEMP_EFI}" 2>&1 )"; then
  error "Unable to remove .cmdline from input: ${objout}"
fi

TEMP_KCL="$(mktemp)"

if [ -n "${ARG_VAR}" ]; then
  echo -n "${ARG_VAR}" > "${TEMP_KCL}"
elif [ -n "${ARG_FILE}" ]; then
  if ! cp "${ARG_FILE}" "${TEMP_KCL}"; then
    error "Failed to copy argument file"
  fi
else
  if ! objout="$( objcopy --dump-section .cmdline="${TEMP_KCL}" "${INPUT_EFI}" 2>&1 )"; then
    error "Unable to extract cmdline from input: ${objout}"
  fi

  clean_kcl "${TEMP_KCL}"

  if [ -n "${PRINT_ONLY}" ]; then
    cat "${TEMP_KCL}"
    exit
  fi

  if ! command -v "${EDITOR:=vi}" >/dev/null 2>&1 ; then
    error "Define \$EDITOR to edit"
  fi

  if ! "${EDITOR}" "${TEMP_KCL}"; then
    error "Failed to edit kernel command-line for input EFI executable"
  fi
fi

clean_kcl "${TEMP_KCL}"

# Pad with a space; replicating Dracut behavior.
# FIXME: Is this strictly needed?
sed -i 's/^/ /' "${TEMP_KCL}"

# Add a null terminator for the efi stub; replicating Dracut behavior
echo -ne "\x00" >> "${TEMP_KCL}"

if objout="$( objcopy --add-section .cmdline="${TEMP_KCL}" --change-section-vma .cmdline=0x30000 "${TEMP_EFI}" 2>&1 )"; then
  if [ -n "${OUTPUT_EFI}" ]; then
    if ! cp "${TEMP_EFI}" "${OUTPUT_EFI}" ; then
      PRESERVE_TEMP_EFI=1
      error "Unable to save to ${OUTPUT}, saved as ${TEMP_EFI}"
    fi
  else
    cat "${TEMP_EFI}"
  fi
else
  error "Unable to add command line: ${objout}"
fi
